<template>
  <section class="content" :class="{ ja: displayLanguage === 'ja' }">
    <Breadcrumb :title="title" />

    <div
      class="japanese-available content-top-full"
      v-if="(userLanguage === 'ja' || isDev) && content.ja && content.en"
    >
      <template v-if="displayLanguage !== 'ja'">
        <img src="~/assets/icons/japanFlag.svg" class="flag-icon" />
        <span>日本語版もあります。</span>
        <span class="button invert" @click="setLanguage('ja')">切り替える</span>
      </template>
      <template v-else>
        <span>日本語版を表示しています。</span>
        <span class="button invert" @click="setLanguage('en')">英語に戻る</span>
      </template>
    </div>

    <h1 :class="{ ja: displayLanguage === 'ja' }" @click="resetView">
      {{ titleInLanguage }}
    </h1>

    <PostDetails
      class="details"
      :category="category"
      :mapPosition="mapPosition"
      :city="city"
      :date="date"
    />

    <LoaderIcon v-if="loading" :active="loading" :absolute="false" />

    <article
      v-lazy-container="{
        selector: 'img[data-src]',
        preLoad: 1.5, // screen heights away to start loading
      }"
      class="markdown"
      ref="postcontent"
      v-html="contentToDisplay"
    ></article>

    <RelatedArticles :city="city" :current="slug" />

    <ContentFooter />
  </section>
</template>

<script>
import axios from 'axios'
import ContentFooter from '~/components/Footer'
import PostDetails from '~/components/PostDetails'
import RelatedArticles from '~/components/RelatedArticles'
import Breadcrumb from '~/components/Breadcrumb'
import LoaderIcon from '~/components/LoaderIcon'
const { capitalize } = require('~/assets/commonFunctions.js')

export default {
  head() {
    return {
      title: this.capitalize(this.title),
      meta: [
        { property: 'og:title', content: this.capitalize(this.title) },
        { hid: `og:type`, property: 'og:type', content: 'article' },
        {
          hid: `og:description`,
          property: 'og:description',
          content: this.description,
        },
        {
          property: 'description',
          content: this.description,
          hid: `description`,
        },
        {
          property: 'og:url',
          content: `https://www.travelingcircusofurbanism.com${
            this.publicPath
          }`,
        },
        {
          hid: `og:image`,
          property: 'og:image',
          content: this.image // does it have an image?
            ? this.image.substring(0, 4) === 'http' // is it external?
              ? this.image // if so, use it
              : `https://www.travelingcircusofurbanism.com${encodeURI(
                  this.image
                )}` // otherwise, give it a prefix
            : 'https://www.travelingcircusofurbanism.com/assets/sitethumbnail.jpg', // fallback to the site thumbnail.
        },
      ],
      // script: [
      //   { src: '/assets/pinit.js', defer: true, async: true, "data-pin-hover":"true", "data-pin-round":"true" }
      // ]
    }
  },

  components: {
    ContentFooter,
    RelatedArticles,
    PostDetails,
    Breadcrumb,
    LoaderIcon,
  },

  asyncData({ route, redirect, error, env, store }) {
    const removeTrailingSlash = string => string.replace(/\/$/, '')
    const slug = removeTrailingSlash(decodeURI(route.path))

    const path = '/posts' + slug + '/'
    const publicPath = '/' + slug + '/'

    let city = route.path.substring(1)
    city = decodeURI(city.substring(0, city.indexOf('/'))).toLowerCase()

    const autoGeneratedData = store.state.allPosts.find(
      p => city === p.city && slug.indexOf(p.slug) !== -1
    )
    if (!autoGeneratedData) {
      // console.log('Error: Unable to find generated data for ' + path)
      return error({ statusCode: 404, message: 'Page not found.' })
    }

    return {
      path,
      publicPath,
      slug,
      city,
      ...autoGeneratedData,
      mapPosition: autoGeneratedData.mapPosition
        ? Array.isArray(autoGeneratedData.mapPosition)
          ? autoGeneratedData.mapPosition
          : [autoGeneratedData.mapPosition]
        : [],
      polygons: autoGeneratedData.polygons ? autoGeneratedData.polygons : null,
    }
  },

  data() {
    return {
      displayLanguage: 'en',
      loading: true,
      content: {
        en: null,
        ja: null,
      },
    }
  },

  computed: {
    isDev() {
      return this.$store.state.isDev
    },
    isMobile() {
      return this.$store.state.isMobile
    },
    userLanguage() {
      return this.$store.state.language
    },
    publicPosts() {
      return this.$store.state.enPublicPosts
    },
    allPosts() {
      return this.$store.state.allPosts
    },
    titleInLanguage() {
      return this.displayLanguage === 'ja' ? this.jaTitle : this.title
    },
    contentInRightLanguage() {
      const contentInRightLanguage =
        this.content[this.displayLanguage || 'en'] || this.content.ja || ''
      return contentInRightLanguage
    },
    contentToDisplay() {
      if (!this.contentInRightLanguage.length) return ''
      const contentToDisplay = this.highlightLocationText()
      this.$nextTick(this.addImageInteraction)
      this.$nextTick(this.addMapMoveOnHighlightTextHover)
      return contentToDisplay
    },
  },

  watch: {},

  async created() {
    if (!process.browser) return
    const axiosConfig = {
      validateStatus: status => true,
    }

    const contentPromises = []

    try {
      if (this.languages.en)
        contentPromises.push(
          axios
            .get(this.path + 'content.html', axiosConfig)
            .then(response => {
              this.$set(this.content, 'en', response.data)
            })
            .catch(e => console.log(e))
        )
      if (this.languages.ja)
        contentPromises.push(
          axios
            .get(this.path + 'ja.html', axiosConfig)
            .then(response => {
              this.$set(this.content, 'ja', response.data)
            })
            .catch(e => console.log(e))
        )
      await Promise.all(contentPromises)
    } catch (e) {
      console.log(e)
      return this.$router.push('/')
    }

    if (!(this.content.en || this.content.ja)) return this.$router.push('/')
    if (this.content.en) this.setLanguage('en')
    else this.setLanguage('ja')
    this.loading = false
  },

  mounted() {
    this.displayLanguage = this.content.en ? 'en' : 'ja'
    this.resetView()
    this.$store.commit(
      'setHighlight',
      this.polygons
        ? Array.isArray(this.mapPosition)
          ? [...this.mapPosition, ...this.polygons]
          : [this.mapPosition, ...this.polygons]
        : this.mapPosition
    )
    this.$nextTick(() => {
      if (!this.public && !this.isDev)
        this.$store.commit('setMapMarkers', this.allPosts)
    })
  },

  beforeDestroy() {
    if (!this.public && !this.isDev)
      this.$store.commit('setMapMarkers', this.publicPosts)
    this.$store.commit('setHighlight')
    this.$store.commit('setViewPolygons')
  },

  methods: {
    capitalize,

    doubleHighlight(location) {
      this.$store.commit('setHighlight', location)
    },

    unDoubleHighlight() {
      this.$store.commit('setHighlight')
    },

    setLanguage(language) {
      this.displayLanguage = language
    },

    resetView() {
      this.$store.commit('setView', this.mapPosition)
      this.$store.commit('setViewPolygons', this.polygons)
      this.$store.commit('setCity', this.city)
      this.$store.commit('setPan', false)
    },

    highlightLocationText() {
      if (
        (!this.mapPosition && !this.polygons) ||
        (!Array.isArray(this.mapPosition) && !this.polygons) ||
        (this.mapPosition.length === 1 && !this.polygons) ||
        this.isMobile
      )
        return this.contentInRightLanguage
      let newContent = this.contentInRightLanguage.replace(/&amp;/g, '&')
      console.log(newContent)
      const toCheck = this.polygons
        ? [...this.mapPosition, ...this.polygons]
        : this.mapPosition
      toCheck
        .map(positionObject => positionObject.location)
        .forEach(location => {
          if (location.length < 4) return
          const locationRegex = new RegExp(`[\s\n >]${location}`, 'gi')
          newContent = newContent.replace(locationRegex, match => {
            console.log(match, location)
            return match.replace(
              new RegExp(`${location}`, 'gi'),
              `<span class="highlight">${location}</span>`
            )
          })
        })
      return newContent
    },

    addMapMoveOnHighlightTextHover() {
      if (
        (!this.mapPosition && !this.polygons) ||
        (!Array.isArray(this.mapPosition) && !this.polygons) ||
        (this.mapPosition.length === 1 && !this.polygons) ||
        this.isMobile ||
        !this.$refs ||
        !this.$refs.postcontent
      )
        return
      const toCheck = this.polygons
        ? [...this.mapPosition, ...this.polygons]
        : this.mapPosition
      this.$refs.postcontent.querySelectorAll('.highlight').forEach(e => {
        const elText = e.innerHTML.toLowerCase().replace('&amp;', '&')
        const foundLocation = toCheck.find(
          p => p.location && elText === p.location.toLowerCase()
        )
        if (foundLocation) {
          e.addEventListener('mouseover', () => {
            this.doubleHighlight(foundLocation.location)
            if (foundLocation.coordinates) {
              this.$store.commit('setView')
              this.$store.commit('setViewPolygons', [foundLocation])
            } else this.$store.commit('setView', foundLocation)
          })
          e.addEventListener('mouseout', this.unDoubleHighlight)
        }
      })
    },

    addImageInteraction() {
      if (!this.$el) return
      this.$el.querySelectorAll('img').forEach(e => {
        e.addEventListener('click', () =>
          this.$store.commit('setLightboxSrc', e.getAttribute('src'))
        )
      })
    },
  },
}
</script>

<style lang="scss" scoped>
@import '~/assets/variables.scss';

h1 {
  margin-bottom: $unit * 2;
}

.japanese-available {
  background: $active;
  color: white;
  margin-bottom: $content-padding;
  margin-top: -3 * $unit;
  text-align: center;

  @include width(mobile) {
    margin-bottom: $content-padding-mobile;
  }
}

.markdown {
  min-height: 50vh;
}

.details {
  @include width(mobile) {
    margin-top: 0;
  }
}
</style>
